 Title:  Writeup for Project 2, Fall 2015
 Date:  10/18/15
 Group:	27
 Name					Email	
 Allen Almasi				asalmasi@usc.edu
 Victoria Dea				vdea@usc.edu
 Gabriel Mel de Fontenay		meldefon@usc.edu
 

I. Requirements:
	+ Part 1
		This part requires us to implement the system calls Acquire and Release for the Lock class as well as Wait, Signal, and Broadcast for the Condition class. In addition we have to implement the constructor and destructor system calls CreateLock, DestroyLock, CreateCondition and DestroyCondition. The system calls have to be protected from user program errors so user programs cannot crash the OS. For example, CreateLock and CreateCondition has to return an interger value so the user does not handle the kernel space pointer directly. Finally, we have to create a test suite to prove that these system calls work and do not crash Nachos when used correctly and incorrectly. 

	+ Part 2
		This part requires us to implement the Exec and Fork system calls to allow for multiprogramming in Nachos. We have to come up with a way to allocate physical memory frames so multiple programs can be loaded into memory at once as well as create a way to copy data between the kernel and the user’s virtual address space. We are also required to create a test suite to prove that these system calls work and do not crash Nachos when used correctly and incorrectly.

	+ Part 3
		This part requires us to recreate the Passport Office from project 1, part 2 as a set of multithreaded Nachos user programs, using the system calls created during this project. We are also required to create a test suite to prove that the implementation works correctly. 

-Describe what's your understanding of the requirements from the assignment statement. With the requirement analysis, you would be clear about what you are supposed to do.

II. Assumptions:
	For our assumptions, we assumed that:


III. Design:
	+ Part 1

	+ Part 2

	+ Part 3	

- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.

IV. Implementation:
	+ Part 1
		+ Files Modified
			userprog/exception.cc
			userprog/syscall.h
			test/start.s
			threads/system.cc
			threads/system.h
			userprog/Makefile

		+ Files added
			threads/structs.h
			test/testpart1.c

		+ Data Structures added, and the file they were added to.
			//In file structs.h:
				struct KernelLock {}
				struct KernelCondition {}
                struct ProcessEntry {}

		+ Data Structures modified, and the file they were added to.
			-For example,
				class Lock		-- in file threads.cc/threads.h
				{
					//. Modified fields.
				}
                class AddressSpace{
                    //Added in a stacak bitMap to allocate free stacks for newly forked threads
                    //Added in a process ID to keep track of the process that owns an address space
                }
                

		+ Functions added and in which file.
			//In file exception.cc:
				Acquire_Syscall(int id);
				Release_Syscall(int id);
				Wait_Syscall(int id);
				Signal_Syscall(int id);
				Broadcast_Syscall(int id);
				CreateLock_Syscall();
				DestroyLock_Syscall(int id);
				CreateCondition_Syscall();
				DestroyCondition_Syscall(int id);

			//In file syscall.h:
				CreateLock();
				DestroyLock(int id);
				Acquire(int id);
				Release(int id);
				CreateCondition();
				DestroyCondition(int id);
				Signal(int id);
				Wait(int id);
				Broadcast(int id);

			//In file testpart1.c
				LockTest();
				ConditionTest();
				AcquireAndReleaseTest();
				WaitSignalBroadcastTest();

		+ Functions modified and in which file.
			//In file exception.cc:
				ExceptionHandler(ExceptionType which);


	+ Part 2
		+ Files Modified
			userprog/syscall.h
			userprog/exception.cc
            userprog/addrspace.h
            userprog/addrspace.cc
            userprog/progtest.cc
            threads/thread
            threads/system.h
            threads/system.cc
            machine/machine.h
            test/testfiles.c
            test/matmult.c
            test/sort
		+ Files added
            No files added, only modified
		+ Data Structures added, and the file they were added to.
            Only created one new structure - the processEntry structure for the process table
            //In structs.h
            ProcessEntry{
                int pID
                int numThreads
                bool running
            }
                
		+ Data Structures modified, and the file they were added to.
			class Thread{
                //Added in a base stack address int for delete upon exit
            }
            class AddrSpace{
                //Added in a stack bit map to help with stack allocation
                //Added numNonStackPages to help with stack address computation
                //Added a stack bit map lock to protect clears and finds
                //Added in a process ID int to keep track of a process index

                //Added in a new method with, in a threadsafe way, finds a new 
                //stack space for a forked thread. Uses the bit map lock
            }

		+ Functions added and in which file.
            //In addrspace.cc:
                Added a method for finding new stack spaces for forked threads
            //In exception.cc:
                - Added in a kernel_fork method which
                    - is forked after the fork syscall. u
                    - used to set registers, page table, and call Machine->run()
                - Added in a kernel_exec method which
                    - is thread forked to after an exec_syscall.
                    - sets registers, page table and calls Machine->run()
                
		+ Functions modified and in which file.
            //In addrspace.cc:
                Modified the addresspace constructor
                    - to have a process ID
                    - To have a set of stack pages allocated on fork
                    - to use a global physical memory bitmap for loading
            //In progtest.cc:
                Modified start process to do the same things as in the address
                space constructor
            //In exception.cc:
                Modified Exec_syscall
                    - To open the executable file
                    - To add a new entry to the process table, which has 1 
                    thread, is set to running, and has an incremented pID
                    - Creates a new address space, which keeps track of its
                    pID, reads the executable into bitmap find spots in physical
                    memory, and instantiates a stack bitmap
                Modified Fork_syscall
                    - To create a new thread,
                    - set the threads addresspsace to the current address 
                    space
                    - sets its stack, and increments the process table's entry 
                    for that process to have one more running thread
                Modified Exit_syscall
                    - To halt the machine is there is only one last thread
                    - To delete the address space and kernel data, and free the
                    phyiscal memory pages when a process's last thread exits
                    - To free a thread's stack pages when it is not the last
                    thread in an exit
                    
                

	+ Part 3
		+ Files Modified
		+ Files added

		+ Data Structures added, and the file they were added to.
		+ Data Structures modified, and the file they were added to.
			-For example,
				class Lock		-- in file threads.cc/threads.h
				{
					//. Modified fields.
				}

		+ Functions added and in which file.
		+ Functions modified and in which file.
	

V. Testing:  (For each test case, you must show)
	+ Part 1
		+ How to test
			To run tests for part 1, compile in the /test directory, then go to the /userprog directory and type the command "nachos -x ../test/testpart1"

		+ Test Output
			The structure of the output for each section of the test begins with a title, specifying which system calls are being tested. Each test case output begins with "Test: " followed by a short description of what is being tested. There may be some intermediate print statements from the kernel and the last line for one case should end with "Result: " followed by "Success". If any of the test cases failed, the result will say "Fail".
	
	+ Part 2
		+ How to test
			To run tests for part 2, compile in the /test directory, then go to the /userprog directory and type the command "nachos -x ../test/testpart2"
	
		+ Test Output
	
	
	+ Part 3
		+ How to test
			To run tests for part 3, compile in the /test directory, then go to the /userprog directory and type the command "nachos -x ../test/threadtest". It will bring up a menu to choose to run the TestSuite or the Simulation. Enter ‘1’ for the TestSuite. Then  You will be provided with a menu that lists seven test options, each of which exactly say what each test is ready to show. To run a test, simply enter the number of the test as an integer argument. The test will run and show the behavior that is indicated in the criteria and then return the user to the beginning of the test menu again. 

		+ Test Output
			Here the outputs that will be shown by each test which are specified by the test number.
		1: There will be 10 customer threads started with no other clerk threads present. There will be 3 inactive application clerks and 3 inactive picture clerks. It will be shown that customers get into line one at a time, and that they will always pick either the shortest bribe line or regular line. The correct flow of customers will be demonstrated by following the output as to who gets in line first and in which line. All lines start with zero count.
		2: We instantiate 5 customers and 1 clerk each. The manager periodically prints totals, which show that office sales are correctly tracked. Note that depending on the random seed used,  the manager does not print the totals after every change, and also that he may not report the totals at the end. This is an unavoidable thread issue. But by checking the totals as they change, we see that the manager is behaving as expected.
		3: There will be 5 customer threads and 1 cashier thread in this test. In this test, the customers will approach the Cashier one at a time and leave once they have paid; for the purpose of this test, the customer has been assumed to have completed all interactions with the other clerks. In addition, the Cashier will only serve another customer once the customer has left the passport office. The correct output will be demonstrated by observing that the customer leaves then the Cashier begins to conduct transactions again once he is gone.
		4: There will be 1 thread of each type of clerk in this test. The clerk threads will all start and then go on break since there will be no customers in line for any of them. The output will show clerks going on break followed by the test terminating once they are all gone.
		5: There will be 5 customer threads, 1 cashier thread, and 1 manager. The cashier will start on break and the customers will begin to line up behind the cashier. Once the cashier’s line count exceeds 3, the cashier will then be woken up by the manager and the customer’s will effectively be able to conduct their business and leave the passport office. The output should show the cashier going on break followed by the customer’s lining up; it should then show the manager waking up the cashier and the customers then conducting business then leaving.
		6: We instantiate 10 customers and 1 clerk each. If there were race conditions affecting the total office sales, one would expect that with so many customers, the total sales might differ from run to run. By running this scenario multiple times and verifying that the total sales are always 1000, this test demonstrates that the total sales are not subject to a race condition.
		7: We run a scenario with 4 customers, 1 clerk each, and 1 senator. You can verify that the normal customers (customers 0-3) are served and leave the passport office, but ONLY AFTER the senator (customer 4) is served and leaves. Running the scenario multiple times adds certainty that the customers and senators are behaving as expected.

VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.











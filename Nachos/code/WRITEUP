 Title:  Writeup for Project 3, Fall 2015
 Date:  11/8/15
 Group:	27
 Name					Email	
 Allen Almasi				asalmasi@usc.edu
 Victoria Dea				vdea@usc.edu
 Gabriel Mel de Fontenay		meldefon@usc.edu
 

I. Requirements:
	+ Part 1:
		This part requires us to create code to manage the TLB. This part will be done in 2 steps: in step 1 we will populate the TLB from our Page Table, and in step 2 we will implement an Inverted Page Table. We are required to show that a single program that fits in main memory will run to completion and that 2 programs that fit in main memory together will run to completion in different address spaces. 

	+ Part 2:
		This part requires us to implement virtual memory. Nothing will be preloaded from the executable when a process starts up. Pages have to be able to move between disk and memory, and pages will need to be evicted when memory fills up using Random and FIFO page replacements. We need a swapfile for evicted pages that are dirty. We have to show that 2 or more programs that are larger than 32 pages are able to run to completion.

	+ Part 3:
		This part requires us to implement networking in nachos. We will implement Remote Procedure Calls for all Lock, Condition Variable and Monitor Variable system calls. The system calls will be sent as a message from a nachos client to a nachos server. The server will process the system call and return the results of the system call to the client. The server has to be able to handle multiple clients. 

II. Assumptions: - Reasonable assumptions you take for your scheme.
	+ Part 1


	+ Part 2


	+ Part 3
	

III. Design:
	+ Part 1
		To complete part 1 we have to populate the TLB from our existing page table and then implement the IPT. To populate the TLB, we need to compute the virtual page number, which is virtual address divided by page size, and then find the entry in the current thread's page table using the virtual page number. We then copy both the virtual and physical page numbers from the page table to the spot in the TLB. Next, we need the IPT, which is needed to keep track of what is or is not loaded into physical memory. In the IPT, we need to keep track of the processes that owns a particular virtual page. The IPT will be implemented as an array with a size of NumPhysPages entries. When ever a BitMap Find() occurs, that value will be put in the IPT. We then copy both the virtual and physical page numbers from the page table to the IPT. 

	+ Part 2
		In this part, we are going to stop preloading pages into memory and only load it when it is needed during program execution so we have to comment out anywhere a BitMap Find() is performed. The BitMap Find() will only be used when there is a PageFaultException and an IPT miss. We add another condition to the function that handles page faults in order to catch and handle the IPT misess. Handling an IPT miss consists of doing a BitMap Find() and checking the page table entry to see where the virtual page maps to on the disk. We will add the byte offset and the disk location to the page table entries so we know if we have to read a page from the executabl when we get an IPT miss. The page table will be updated with the physical page number with the valid bit set to true so we know when to evict memory pages on an Exit syscall. When an IPT miss occurs and the memory is full, we need to evict a memory page to make room for the one we need to load. This will be done in HandleMemoryFull(). If a page is dirty it will be copied to the swapfile and a BitMap object will be used to keep track of where the the page was put in the swapfile. The evicted page's process page table will then be updated. 

	+ Part 3
		

- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.

IV. Implementation:
	+ Part 1
		+ Files Modified

		+ Files added

		+ Data Structures added, and the file they were added to.

		+ Data Structures modified, and the file they were added to.
			-For example,
				class Lock		-- in file threads.cc/threads.h
				{
					//. Modified fields.
				}

		+ Functions added and in which file.
		+ Functions modified and in which file.

	+ Part 2
		+ Files Modified
		+ Files added
		+ Data Structures added, and the file they were added to.
		+ Data Structures modified, and the file they were added to.
		+ Functions added and in which file.
		+ Functions modified and in which file.


	+ Part 3
		+ Files Modified
		+ Files added
		+ Data Structures added, and the file they were added to.
		+ Data Structures modified, and the file they were added to.
		+ Functions added and in which file.
		+ Functions modified and in which file.

V. Testing:  (For each test case, you must show)
	+ Part 1
		+ How to test
			- How to run the test cases, the commands, the arguments and so on.
		+ Test Output
			- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output. The grader of your submission will be wanting to compare the output they get with what you say the output is.

	+ Part 2
		+ How to test
		+ Test Output

	+ Part 3
		+ How to test
		+ Test Output




VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.

 Title:  Writeup for Project 1, Fall 2015
 Date:  09/20/15
 Group:	27
 Name					Email	
 Allen Almasi				asalmasi@usc.edu
 Victoria Dea				vdea@usc.edu
 Gabriel Mel de Fontenay		meldefon@usc.edu
 

I. Requirements:
	+ Part 1
		This part required us to implement the lock and condition variable (CV). We added the private data needed for the locks and CV in the header file. We implemented the functions Acquire() and Release() for the Lock class and Wait(), Signal(), and Broadcast() for the Condition class in synch.cc. Then we tested the code using the test in test_code.cc provided on Blackboard. 

	+ Part 2
		This part required us to simulate a US Passport Office that features various clerks who serve customers that want to get a passport. The clerk roles are ApplicationClerk, PictureClerk, PassportClerk, and Cashier. There is a Manager that controls when clerks go back to work. There are also two types of customers, the normal customer and the Senator. Each entity is simulated as an individual thread with a specific set of tasks to complete.  The general goal of this part is to successfully synchronize all of the clerk and customer threads in order to prevent race conditions when they all try to access any shared data at the same time or attempt to complete tasks out of order. We are also required to develop repeatable tests for the simulation in order to prove that the simulation fulfils the given requirements. 


II. Assumptions:
	For our assumptions, we assumed that: clerks and customers would be not objects, but individual functions serving as objects; we need a variety of global variables to share data between functions; we needed a main function to initialize all the threads, data structures, and variables; assumed that when clerks go on break, customers can still line up since this would avoid clerks going back on break again once being woken up; and data sharing in thread-to-thread interaction could be done in anyway we wanted as long as it happened in the correct order.

III. Design:
	+ Part 1
		For the Locks and Condition Variable functions, we used the more primitive thread routine instead of semaphores because we followed the algorithm given to us in lecture by the professor. 
		The Lock class has two operations that are allowed to be performed on a Lock. The functions are Acquire and Release and they are both atomic operations that controls whether a Lock is Free or not for another thread to use. 
		The Condition class defines a condition variable which synchronizes threads that are waiting to access shared data that is protected by a lock. It has 3 functions: Wait, Signal, and Broadcast.  Wait is an atomic function that puts a calling thread on a wait queue and releases its lock before going to sleep. Signal wakes 1 sleeping thread from the wait queue and makes it ready to run. Broadcast does the same but with all the threads on the wait queue. 

	+ Part 2 
		For Part 2, we began our design by first discussing what data structures and variables we would need. During this process, realized the need for a lot of data sharing between threads and thus devised a way for global data sharing primarily using a struct and a few other primitive global variables. To do this, we first created a struct called Monitor that holds all of our locks, monitor variables, and condition variables needed to implement thread synchronization. Each monitor would be associated with each respective clerk, and would contain all necessary tools to make synchronization happen; we also felt this would be a cleaner approach since we could simply pass around pointers to monitors while calling the same functions. Using the struct Monitor, we then created four global monitor variables for each clerk that would be passed around our code. Alongside the four global struct Monitors, we also created a few primitive global variables that would be used to record shared data such as cash received, customers with completed applications or pictures, the number of customers left, and etc.. 
Having discussed the necessary data structures and variables needed for the simulation, we can now discuss the functions and flow of the program needed to make it all work. Firstly, we created two new files called clerks.cpp and customer.cpp. In clerks.cpp, we placed all the clerks--including the manager--in their own functions for the specific thread-to-thread interaction with the customer. Alongside, we also created and used a variety of general helper functions for the clerks that would do tasks such as managing the lines or signalling customers in order to avoid copy-pasting the same code every time. In customer.cpp, we had a function called customer that is essentially a scheduler that would dictate what tasks a customer had left to do by calling other specific functions in the file; these specific functions would be the thread-to-thread interaction code between a clerk and customer. In addition, we also placed the Senator function in customers.cpp with the same approach since a Senator is essentially a special type of customer. Last but not least, the “main” of our simulation where all the threads, data structures, and global variables are initialized is in threadtest.cc. In threadtest.cc, we ask the user to input specific parameters regarding the number of clerks and customers, then initialize all the threads and necessary variables to make the simulation work.  


IV. Implementation:
	+ Part 1
		+ Files Modified
			synch.h
			synch.cc

		+ Data Structures modified, and the file they were added to.

				class Lock		-- in file synch.cc synch.h
				{
					//added private variables
    					Thread* owner;
    					List *lockWaitQueue;
    					bool isFree;
				}

				class Condition		-- in file synch.cc synch.h
				{
					//added private variables
					Lock* waitingLock;
    					List *waitQueue;
				}

		+ Functions added and in which file.
			// Added in file synch.cc synch.h
			Lock();
			Condition();

		+ Functions modified and in which file.

			// Lock Functions modified in file threads.cc
			    Lock(char* debugName);
			    ~Lock(); 
			    void Acquire(); 
			    void Release(); 
			    bool isHeldByCurrentThread(); 

			// Condition Functions modified in file threads.cc
			Condition(char* debugName);
			    ~Condition();
			    void Wait(Lock *conditionLock);
			    void Signal(Lock *conditionLock);
			    void Broadcast(Lock *conditionLock);
	
	+ Part 2
		+ Files Modified
			threadtest.cc
		+ Files added
			clerks.cpp
			customer.cpp
			globalVars.h
			monitor.h

		+ Data Structures added, and the file they were added to.
			//Added to file monitor.h
			struct Monitor(){}

		+ Functions added and in which file.
			//Added in file clerks.cpp
			waitForLine(Monitor* clerk, int myLineID, bool firstTime)
			pictureClerk(int id)
			applicationClerk(int id)
			passportClerk(int id)
			cashierDo(int id)
			checkForClerkOnBreak(Monitor *clerk)
			managerDo(int id)

			//Added in file customer.cpp
			punish(int time)
			tellPassportClerkSSN(int SSN,int myLine)
			tellCashierSSN(int SSN,int myLine)
			payCashier(int SSN, int *cash)
			getInLine(Monitor *clerk, int socialSecurityNum, int* cash)
			doAppClerkStuff(int socialSecurityNum, int* cash)
			doPicClerkStuff(int socialSecurityNum, int* cash)
			doPassportClerkStuff(int socialSecurityNum,int*cash)
			doCashierStuff(int mySSN, int* cash)
			customer(int social)

			//Added in file monitor.h
			initialize(char* lockName, char* clerkType_, int size)

		+ Functions modified and in which file.
			//Modified in threadtest.cc
			ThreadTest()


V. Testing: 

	+ Test Cases (and their corresponding numbers):
		1. Customers always take the shortest line, but no 2 customers ever choose the same shortest line at the same time
		2. Managers only read one from one Clerk's total money received, at a time.
		3. Customers do not leave until they are given their passport by the Cashier. The Cashier does not start on another customer until they know that the last Customer has left their area
		4. Clerks go on break when they have no one waiting in their line
		5. Managers get Clerks off their break when lines get too long
		6. Total sales never suffers from a race condition
		7. The behavior of Customers is proper when Senators arrive. This is before, during, and after.

	+ How to test
		To test each criteria, type in the nachos command “nachos -P2” to bring up the test menu. You will be provided with a menu that lists seven test options, each of which exactly say what each test is ready to show. To run a test, simply enter the number of the test as an integer argument. The test will run and show the behavior that is indicated in the criteria and then return the user to the beginning of the test menu again. 

	+ Test Output
		Here the outputs that will be shown by each test which are specified by the test number.
		1: There will be 10 customer threads started with no other clerk threads present. There will be 3 inactive application clerks and 3 inactive picture clerks. It will be shown that customers get into line one at a time, and that they will always pick either the shortest bribe line or regular line. The correct flow of customers will be demonstrated by following the output as to who gets in line first and in which line. All lines start with zero count.
		2:
		3: There will be 5 customer threads and 1 cashier thread in this test. In this test, the customers will approach the Cashier one at a time and leave once they have paid; for the purpose of this test, the customer has been assumed to have completed all interactions with the other clerks. In addition, the Cashier will only serve another customer once the customer has left the passport office. The correct output will be demonstrated by observing that the customer leaves then the Cashier begins to conduct transactions again once he is gone.
		4: There will be 1 thread of each type of clerk in this test. The clerk threads will all start and then go on break since there will be no customers in line for any of them. The output will show clerks going on break followed by the test terminating once they are all gone.
		5: There will be 5 customer threads, 1 cashier thread, and 1 manager. The cashier will start on break and the customers will begin to line up behind the cashier. Once the cashier’s line count exceeds 3, the cashier will then be woken up by the manager and the customer’s will effectively be able to conduct their business and leave the passport office. The output should show the cashier going on break followed by the customer’s lining up; it should then show the manager waking up the cashier and the customers then conducting business then leaving.
		6:
		7:


VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		The expectation of our experiment was that the simulation would run without any race conditions or deadlocks; in other words, it would be synchronized. Essentially, all thread-to-thread interactions are to happen in the order dictated by the guidelines and all shared data is to be modified one at a time. We will use the tests and a complete passport office simulation to show this.
	+ Experiment result.  (What actually happened.)
		Our result was that everything did run in synchronized order as the guidelines had specified; this can be see in the output of the tests alongside the complete passport office simulation.
	+ Explanation
		Our explanation for why everything worked is quite simple: we effectively used locks with shared data, and condition variables when dictating the order by which threads access this shared data. All of our tests, including the simulation, run the clerk and customer functions without any modification; nothing is hard-coded or pseudo. 
	
VIII. Miscellaneous:





 Title:  Writeup for Project 3, Fall 2015
 Date:  11/8/15
 Group:	27
 Name					Email	
 Allen Almasi				asalmasi@usc.edu
 Victoria Dea				vdea@usc.edu
 Gabriel Mel de Fontenay		meldefon@usc.edu
 

I. Requirements:
	+ Part 1:
		This part requires us to create code to manage the TLB. This part will be done in 2 steps: in step 1 we will populate the TLB from our Page Table, and in step 2 we will implement an Inverted Page Table. We are required to show that a single program that fits in main memory will run to completion and that 2 programs that fit in main memory together will run to completion in different address spaces. 

	+ Part 2:
		This part requires us to implement virtual memory. Nothing will be preloaded from the executable when a process starts up. Pages have to be able to move between disk and memory, and pages will need to be evicted when memory fills up using Random and FIFO page replacements. We need a swapfile for evicted pages that are dirty. We have to show that 2 or more programs that are larger than 32 pages are able to run to completion.

	+ Part 3:
		This part requires us to implement networking in nachos. We will implement Remote Procedure Calls for all Lock, Condition Variable and Monitor Variable system calls. The system calls will be sent as a message from a nachos client to a nachos server. The server will process the system call and return the results of the system call to the client. The server has to be able to handle multiple clients. 

II. Assumptions: - Reasonable assumptions you take for your scheme.
	+ Part 1:	
		-We would need to create a new class to hold the IPT entries
		-There is no IPT in Nachos
		-We should do things in a step-by-step approach
	+ Part 2:
		-We would use the Nachos file system for the swap file
		-We would use bitmap for file functionality alongside memory management 
	+ Part 3:
		-We could use stringstream to parse messages
		-Server would be single threaded
		-We did not have to implement thread specific messaging for this project
		-We could use any type of message formatting
		-We would need to create new types of structs to hold the new locks, CVs, and MVs
		-We would need new globals that would be shared across clients

III. Design:
	+ Part 1
		To complete part 1 we have to populate the TLB from our existing page table and then implement the IPT. To populate the TLB, we need to compute the virtual page number, which is virtual address divided by page size, and then find the entry in the current thread's page table using the virtual page number. We then copy both the virtual and physical page numbers from the page table to the spot in the TLB. Next, we need the IPT, which is needed to keep track of what is or is not loaded into physical memory. In the IPT, we need to keep track of the processes that owns a particular virtual page. The IPT will be implemented as an array with a size of NumPhysPages entries. When ever a BitMap Find() occurs, that value will be put in the IPT. We then copy both the virtual and physical page numbers from the page table to the IPT. 

	+ Part 2
		In this part, we are going to stop preloading pages into memory and only load it when it is needed during program execution so we have to comment out anywhere a BitMap Find() is performed. The BitMap Find() will only be used when there is a PageFaultException and an IPT miss. We add another condition to the function that handles page faults in order to catch and handle the IPT misess. Handling an IPT miss consists of doing a BitMap Find() and checking the page table entry to see where the virtual page maps to on the disk. We will add the byte offset and the disk location to the page table entries so we know if we have to read a page from the executabl when we get an IPT miss. The page table will be updated with the physical page number with the valid bit set to true so we know when to evict memory pages on an Exit syscall. When an IPT miss occurs and the memory is full, we need to evict a memory page to make room for the one we need to load. This will be done in HandleMemoryFull(). If a page is dirty it will be copied to the swapfile and a BitMap object will be used to keep track of where the the page was put in the swapfile. The evicted page's process page table will then be updated. 

	+ Part 3
		In part 3, we were required to implement remote procedure calls to establish the basis for server and client communication in Nachos. Our first approach to design this part was to first decide where the server would run and how it would handle client messages via message formatting. Since our server is single threaded, we thought it would be best to create a function called void Server() in the threads directory, in file threadtest.cc, that would serve as the ServerStub and ServerApp. In this function, we would have a while loop that always runs and continually handles client messages one at a time. Once it receives a message, it parses the message based on a specific message format. To accomplish specific message formatting, we used stringstream to pull out specific parts of the message since it seemed the most convenient. In regards to the formatting process: the first entry that is pulled out of a client message is the TYPE of message in the form of a string, which refers to which Syscall is being requested; after this, we use the string we pulled to enter into the specific systemcall code block in our void Server() funciton via switch-case statements where we will continue to use stringstream to pull out the remaining data arguments in the message in order to handle the remote procedure call. It is also in these switch cases where we perform user validation of the input and send back an ERROR value of -1 or success value of -2 to the ClientStub. Having discussed the general procedure of how we handle communication between the ServerStub and ClientStub, we will now turn our attention to the data structures that we used to hold the global locks, CVs, and MVs. Like our previous projects, we felt it would be best to use three structs called ServerLock, ServerCV, and ServerMV, all of which are contain data definitions in serverStructs.h and are not global system variables since they are defined and initialized only in the void Server() function using vector containers. In these structs, we hold information containing owners of locks, CV holders, MV values, etc., and manage them directly in the switch-case statements that pertain to each systemcall. Having defined our structs, we felt that it would be best to use the vectors as containers for these structs to hold them in the void Server() function called vector<ServerLock*> *serverLocks, vector<ServerCV*> *serverCVs, and vector<ServerMV*> *serverMVs, since they will always be continually growing. Once we had our data structures in place, all that was left was to implement the system calls which again sent a reply message of -1 for a success, or -2 for an error, or an actual integer value if one was requested. In the ClientStub, we handled all these syscalls in the appropiate systemcall in exception.cc, just like if it was a normal non-network systemcall, since we felt it would be much easier to manage it directly inside the syscall that made the request rather than creating a new global function which would then have to parse replies based on which syscall was requested.


- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc. This is not code. You must document ALL parts of a project.

IV. Implementation:
	+ Part 1
		+ Files Modified

		+ Files added

		+ Data Structures added, and the file they were added to.

		+ Data Structures modified, and the file they were added to.
			-For example,
				class Lock		-- in file threads.cc/threads.h
				{
					//. Modified fields.
				}

		+ Functions added and in which file.
		+ Functions modified and in which file.

	+ Part 2
		+ Files Modified
		+ Files added
		+ Data Structures added, and the file they were added to.
		+ Data Structures modified, and the file they were added to.
		+ Functions added and in which file.
		+ Functions modified and in which file.


	+ Part 3
		+ Files Modified
		+ Files added
		+ Data Structures added, and the file they were added to.
		+ Data Structures modified, and the file they were added to.
		+ Functions added and in which file.
		+ Functions modified and in which file.

V. Testing:  (For each test case, you must show)
	+ Part 1
		+ How to test
			- How to run the test cases, the commands, the arguments and so on.
		+ Test Output
			- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output. The grader of your submission will be wanting to compare the output they get with what you say the output is.

	+ Part 2
		+ How to test
		+ Test Output

	+ Part 3
		+ How to test
		+ Test Output




VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
	+ Experiment result.  (What actually happened.)
	+ Explanation
		- Explain your experiment result - how it proves what 
		  you were supposed to prove.

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.
